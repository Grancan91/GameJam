<!doctype html>
<html>

<head>
    <script src="https://pixijs.download/release/pixi.min.js"></script>
</head>

<body>
    <script>
        let app = new PIXI.Application({ width: 1280, height: 720 });
        document.body.appendChild(app.view);
        document.addEventListener('keydown', onKeyDown, false);

        /* IMPORTANT VARIABLES */
        const sadCount = 0;
        const angryCount = 0;
        const happyCount = 0;
        const disgustCount = 0;

        /* CONTAINERS */
        const startContainer = new PIXI.Container();
        const gameContainer = new PIXI.Container();
        const endContainer = new PIXI.Container();
        const backg = new PIXI.Container();

        /* ENUMS */
        const colors = {
            DISGUST: "#fffd7e", //yellow
            HAPPY: "#c7ffef", //cyan
            ANGRY: "#a9ff7e", // green
            SAD: "#ff7e7e",  //red
            WHITE: "#ffffff",
            BLACK: "#000000",
            GRAY: "#d7d7d7"
        }
        const screens = {
            START: "start",
            GAME: "game",
            END: "end"
        }

        /* SCREEN CHANGING*/
        /* var currentScreen = screens.START;
        function goToStart(){
            startContainer.visible = true;
            gameContainer.visible = false;
        }

        function goToGame(){
            startContainer.visible = false;
            gameContainer.visible = true;
        }

        switch(currentScreen){
            case screens.START: 
                goToStart();
                break;
            case screens.GAME: 
                goToGame();
                break;
        } */

        // TEXT STYLES
        const titleStyle = new PIXI.TextStyle({
            fontFamily: 'Courier New',
            fontSize: 48,
            fontStyle: 'italic',
            fontWeight: 'bold',
            fill: [colors.WHITE, colors.BLACK], // gradient
            stroke: colors.WHITE,
            strokeThickness: 5,
            dropShadow: true,
            dropShadowColor: colors.BLACK,
            dropShadowBlur: 4,
            dropShadowAngle: Math.PI / 6,
            dropShadowDistance: 6,
        });
        const subtitleStyle = new PIXI.TextStyle({
            fontFamily: 'Courier New',
            fontSize: 36,
            fontStyle: 'italic',
            fontWeight: 'bold',
            fill: [colors.WHITE, colors.GRAY], // gradient
            stroke: colors.BLACK,
            strokeThickness: 5,
            dropShadow: true,
            dropShadowColor: colors.ANGRY,
            dropShadowBlur: 4,
            dropShadowAngle: Math.PI / 6,
            dropShadowDistance: 6,
        });
        const keysStyle = new PIXI.TextStyle({
            fontFamily: 'Courier New',
            fontSize: 20,
            fontStyle: 'italic',
            fontWeight: 'bold',
            fill: [colors.BLACK], // gradient
            stroke: colors.SAD,
            strokeThickness: 5,
        });

        const arrowStyle = new PIXI.TextStyle({
            fontFamily: 'Courier New',
            fontSize: 20,
            fontStyle: 'italic',
            fontWeight: 'bold',
            fill: [colors.BLACK], // gradient
            stroke: colors.DISGUST,
            strokeThickness: 5,
        });

        const withdoutShadowStyle = new PIXI.TextStyle({
            fontFamily: 'Courier New',
            fontSize: 32,
            fontStyle: 'italic',
            fontWeight: 'bold',
            fill: [colors.BLACK], // gradient
            stroke: colors.WHITE,
            strokeThickness: 5,
        });

        const paragraphStyle = new PIXI.TextStyle({
            fontFamily: 'Courier New',
            fontSize: 20,
            fontStyle: 'italic',
            fontWeight: 'bold',
            fill: [colors.BLACK], // gradient
            stroke: colors.WHITE,
            strokeThickness: 5,
            wordWrap: true,
            //wordWrapWidth: 100
        });

        /* BACKGROUND */
        //const texture = new PIXI.Texture('background.jpeg');
        /* texture.width = 1280;
        texture.height = 720; */
        const background = PIXI.Sprite.from('background.jpeg');
        backg.addChild(background);
        app.stage.addChild(backg);

        /* START ELEMENTS */
        // game name
        const title = new PIXI.Text('MY PATH', titleStyle);
        title.x = app.screen.width / 2.5;
        title.y = 30;
        // character
        const ghostSpawn = [
            'SPAWN01.png',
            'SPAWN02.png',
            'SPAWN03.png',
            'SPAWN04.png',
            'SPAWN05.png',
            'SPAWN06.png',
            'SPAWN07.png',
        ];
        const textureArray = [];

        for (let i = 0; i < 4; i++) {
            const texture = PIXI.Texture.from(ghostSpawn[i]);
            textureArray.push(texture);
        }
        const animatedSprite = new PIXI.AnimatedSprite(textureArray, true);
        animatedSprite.animationSpeed = 0.01;
        animatedSprite.play();
        app.stage.addChild(animatedSprite);

        //const ghost = PIXI.Sprite.from('Personaje_jugable_1.png');
       /*  ghost.x = app.screen.width / 2.3;
        ghost.y = 100;
        ghost.scale.set(0.4) */
        // instructions title
        const instruction = new PIXI.Text("Instrucciones", titleStyle);
        instruction.x = app.screen.width / 3;
        instruction.y = 265;
        // moveKeys
        const moveKeys = new PIXI.Text("A, W, S, D", keysStyle);
        moveKeys.x = app.screen.width / 12;
        moveKeys.y = 350;
        // moveArrow
        const moveArrow = new PIXI.Text("->", arrowStyle);
        moveArrow.x = app.screen.width / 4;
        moveArrow.y = 350;
        // moveText
        const moveText = new PIXI.Text("Mover al fantasmita perdido", arrowStyle);
        moveText.x = app.screen.width / 3.6;
        moveText.y = 350;
        // objectiveKey
        const objectiveKey = new PIXI.Text("Objetivo", keysStyle);
        objectiveKey.x = app.screen.width / 12;
        objectiveKey.y = 400;
        // objectiveArrow
        const objectiveArrow = new PIXI.Text("->", arrowStyle);
        objectiveArrow.x = app.screen.width / 4;
        objectiveArrow.y = 400;
        // objectiveText
        const objectiveText = new PIXI.Text("Elegir los cristales emocionales que quieras, para averiguar tu identidad", arrowStyle);
        objectiveText.x = app.screen.width / 3.6;
        objectiveText.y = 400;
        // finish key
        const finishKey = new PIXI.Text("Terminar juego", keysStyle);
        finishKey.x = app.screen.width / 12;
        finishKey.y = 450;
        // finishArrow
        const finishArrow = new PIXI.Text("->", arrowStyle);
        finishArrow.x = app.screen.width / 4;
        finishArrow.y = 450;
        // finishText
        const finishText = new PIXI.Text("Entrar en el portal", arrowStyle);
        finishText.x = app.screen.width / 3.6;
        finishText.y = 450;
        // key to exit
        const escKey = new PIXI.Text("Esc", keysStyle);
        escKey.x = app.screen.width / 12;
        escKey.y = 500;
        // escArrow
        const escArrow = new PIXI.Text("->", arrowStyle);
        escArrow.x = app.screen.width / 4;
        escArrow.y = 500;
        // escText
        const escText = new PIXI.Text("Ir a inicio", arrowStyle);
        escText.x = app.screen.width / 3.6;
        escText.y = 500;
        // start game
        const subTitle = new PIXI.Text('Pulsar X para iniciar tu camino.', subtitleStyle);
        subTitle.x = app.screen.width / 4.3;
        subTitle.y = 600;

        /* ADD ELEMENTS TO CONTAINERS */
        startContainer.addChild(title);
        //startContainer.addChild(ghost);
        startContainer.addChild(instruction);
        startContainer.addChild(moveKeys);
        startContainer.addChild(moveArrow);
        startContainer.addChild(moveText);
        startContainer.addChild(objectiveKey);
        startContainer.addChild(objectiveArrow);
        startContainer.addChild(objectiveText);
        startContainer.addChild(finishKey);
        startContainer.addChild(finishArrow);
        startContainer.addChild(finishText);
        startContainer.addChild(escKey);
        startContainer.addChild(escArrow);
        startContainer.addChild(escText);
        startContainer.addChild(subTitle);
        startContainer.visible = true;
        app.stage.addChild(startContainer);

        /* GAME ELEMENTS */
        let player = PIXI.Sprite.from('Personaje_jugable_1.png');
        let enemy = PIXI.Sprite.from('bunny.png');
        let suelo = PIXI.Sprite.from('Suelo.png');
        let dsert1 = PIXI.Sprite.from('Duna_01.png');
        let dsert2 = PIXI.Sprite.from('Duna_02.png');
        let dsert3 = PIXI.Sprite.from('Duna_03.png');
        let dsert4 = PIXI.Sprite.from('Duna_fondo_01.png');
        let dsert5 = PIXI.Sprite.from('Duna_fondo_02.png');
        let dsert6 = PIXI.Sprite.from('Duna_fondo_03.png');
        let obelisc = PIXI.Sprite.from('Orbe.png');

        // let obeliscAnimation = PIXI.Sprite.from('Fondo_animado_Orbe.png');
        enemy.y = 100
        dsert1.y = 500
        // player.tint = 0x252525

        obelisc.x = 750
        //obeliscAnimation.x = 750

        suelo.y = 650
        dsert1.y = 550
        dsert2.y = 550
        dsert3.y = 550
        dsert4.y = 500
        dsert5.y = 500

        dsert1.x = 100
        dsert2.x = 1000
        dsert3.x = 1800
        dsert4.x = 100
        dsert5.x = 400
        dsert6.x = 800

        // ADD ELEMENTS TO GAME CONTAINER
        gameContainer.addChild(suelo);
        gameContainer.addChild(dsert4);
        gameContainer.addChild(dsert5);
        gameContainer.addChild(dsert6);
        gameContainer.addChild(dsert1);
        gameContainer.addChild(dsert2);
        gameContainer.addChild(dsert3);
        gameContainer.addChild(obelisc);
        //gameContainer.addChild(obeliscAnimation);
        gameContainer.addChild(player);
        gameContainer.addChild(enemy);
        gameContainer.visible = false;
        app.stage.addChild(gameContainer);

        /* THE END ELEMENTS */
        // title
        const endTitle = new PIXI.Text("Has elegido este camino:", titleStyle);
        endTitle.x = app.screen.width / 4.5;
        endTitle.y = 30;
        // sad
        const sad = PIXI.Sprite.from('Personaje_jugable_1.png');
        sad.x = app.screen.width / 12;
        sad.y = 170;
        sad.scale.set(0.3)
        sad.tint = colors.SAD;
        const sCount = new PIXI.Text("x" + sadCount, withdoutShadowStyle);
        sCount.x = app.screen.width / 10;
        sCount.y = 300;
        // happy
        const happy = PIXI.Sprite.from('Personaje_jugable_1.png');
        happy.x = app.screen.width / 3;
        happy.y = 170;
        happy.scale.set(0.3)
        happy.tint = colors.HAPPY;
        const hCount = new PIXI.Text("x" + happyCount, withdoutShadowStyle);
        hCount.x = app.screen.width / 2.8;
        hCount.y = 300;
        // disgust
        const disgust = PIXI.Sprite.from('Personaje_jugable_1.png');
        disgust.x = app.screen.width / 1.7;
        disgust.y = 170;
        disgust.scale.set(0.3)
        disgust.tint = colors.DISGUST;
        const dCount = new PIXI.Text("x" + disgustCount, withdoutShadowStyle);
        dCount.x = app.screen.width / 1.63;
        dCount.y = 300;
        // angry
        const angry = PIXI.Sprite.from('Personaje_jugable_1.png');
        angry.x = app.screen.width / 1.2;
        angry.y = 170;
        angry.scale.set(0.3)
        angry.tint = colors.ANGRY;
        const aCount = new PIXI.Text("x" + angryCount, withdoutShadowStyle);
        aCount.x = app.screen.width / 1.17;
        aCount.y = 300;
        // final image
        const finalImage = PIXI.Sprite.from('Asets/x2/PJx2.png');
        finalImage.x = app.screen.width / 6;
        finalImage.y = 400;
        finalImage.scale.set(0.7);
        finalImage.tint = colors.WHITE;
        // conclusion
        const conclusion = new PIXI.Text('Está enfadado. Relájese :)', paragraphStyle);
        conclusion.x = app.screen.width / 1.5;
        conclusion.y = 400;
        conclusion.tint = colors.WHITE;
        // start game again
        const startAgain = new PIXI.Text('Pulsar X o Esc para volver a inicio', subtitleStyle);
        startAgain.x = app.screen.width / 5;
        startAgain.y = 650;

        /* ADD ELEMENTS TO END*/
        endContainer.addChild(endTitle);
        endContainer.addChild(sad);
        endContainer.addChild(sCount);
        endContainer.addChild(happy);
        endContainer.addChild(hCount);
        endContainer.addChild(disgust);
        endContainer.addChild(dCount);
        endContainer.addChild(angry);
        endContainer.addChild(aCount);
        endContainer.addChild(finalImage);
        endContainer.addChild(conclusion);
        endContainer.addChild(startAgain);

        endContainer.visible = false;
        app.stage.addChild(endContainer);

        /* GAME EXECUTING */
        var pSpeed = 2
        var moveY = 0;
        var moveX = 0;
        var wSpeed1 = 2
        var wSpeed2 = 1

        var moveY = 0;
        var moveX = 0;

        let elapsed = 0.0;
        app.ticker.add((delta) => {
            update(delta);
        });

        function update(delta) {
            elapsed += delta;
            player.y += moveY
            player.x += moveX
            dsert1.x -= wSpeed1
            dsert2.x -= wSpeed1
            dsert3.x -= wSpeed1
            dsert4.x -= wSpeed2
            dsert5.x -= wSpeed2
            dsert6.x -= wSpeed2

            outMap(dsert1)
            outMap(dsert2)
            outMap(dsert3)
            outMapWall(dsert4)
            outMapWall(dsert5)
            outMapWall(dsert6)

            moveX *= 0.99
            moveY *= 0.99
            console.log(moveX)

            if (hitTestRectangle(player, enemy)) {
                console.log("Collision")
                moveY = 0
                moveX = 0
            } else {
                console.log("Not Collision")
            }
        }

        // Movement
        function onKeyDown(key) {
            switch (key.keyCode) {
                case 87:    // W key
                case 38:    // Up arrow key 
                    moveY = -pSpeed;
                    break;
                case 83:    // S key
                case 40:    // Down arrow key
                    moveY = pSpeed;
                    break;
                case 65:    // A key
                case 37:    // Left arrow key
                    moveX = -pSpeed;
                    break;
                case 68:    // D key
                case 39:    // Right arrow key
                    moveX = pSpeed;
                    break;
                case 88:    // X key   
                    //if(currentScreen == screens.START) currentScreen = screens.GAME;
                    if (startContainer.visible) {
                        startContainer.visible = false;
                        gameContainer.visible = true;
                        endContainer.visible = false;
                        backg.visible = false;
                    }
                    else if (endContainer.visible) {
                        startContainer.visible = true;
                        gameContainer.visible = false;
                        endContainer.visible = false;
                        backg.visible = true;
                    } else if (gameContainer.visible) {
                        startContainer.visible = false;
                        gameContainer.visible = false;
                        endContainer.visible = true;
                        backg.visible = true;
                    }
                    break;
                case 27:    // Esc key
                    //if(currentScreen == screens.GAME) currentScreen = screens.START;
                    if (startContainer.visible) {
                        gameContainer.visible = false;
                        endContainer.visible = false;
                    }
                    else if (endContainer.visible) {
                        startContainer.visible = true;
                        gameContainer.visible = false;
                        endContainer.visible = false;
                    } else if (gameContainer.visible) {
                        startContainer.visible = true;
                        gameContainer.visible = false;
                        endContainer.visible = false;
                    }
            }

        }

        // Collisions
        function hitTestRectangle(r1, r2) {
            //Define the variables we'll need to calculate
            let hit, combinedHalfWidths, combinedHalfHeights, vx, vy;
            //hit will determine whether there's a collision
            hit = false;
            //Find the center points of each sprite
            r1.centerX = r1.x + r1.width / 2;
            r1.centerY = r1.y + r1.height / 2;
            r2.centerX = r2.x + r2.width / 2;
            r2.centerY = r2.y + r2.height / 2;
            //Find the half-widths and half-heights of each sprite
            r1.halfWidth = r1.width / 2;
            r1.halfHeight = r1.height / 2;
            r2.halfWidth = r2.width / 2;
            r2.halfHeight = r2.height / 2;
            //Calculate the distance vector between the sprites
            vx = r1.centerX - r2.centerX;
            vy = r1.centerY - r2.centerY;
            //Figure out the combined half-widths and half-heights
            combinedHalfWidths = r1.halfWidth + r2.halfWidth;
            combinedHalfHeights = r1.halfHeight + r2.halfHeight;
            //Check for a collision on the x axis
            if (Math.abs(vx) < combinedHalfWidths) {
                //A collision might be occurring. Check for a collision on the y axis
                if (Math.abs(vy) < combinedHalfHeights) {
                    //There's definitely a collision happening
                    hit = true;
                } else {
                    //There's no collision on the y axis
                    hit = false;
                }
            } else {
                //There's no collision on the x axis
                hit = false;
            }
            //`hit` will be either `true` or `false`
            return hit;
        };

        function outMap(spr) {
            if (spr.x <= -1420) {
                spr.x = 850
                return console.log(spr.x)
            }
        }
        function outMapWall(spr) {
            if (spr.x <= -1420) {
                spr.x = 850
                return console.log(spr.x)
            }
        }

    </script>
</body>

</html>