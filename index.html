<!doctype html>
<html>

<head>
    <script src="https://pixijs.download/release/pixi.min.js"></script>
</head>

<body>
    <script>
        let app = new PIXI.Application({ width: 1280, height: 720 });
        document.body.appendChild(app.view);
        document.addEventListener('keydown', onKeyDown, false);

        /* CONTAINERS */
        const startContainer = new PIXI.Container();
        const instructionsContainer = new PIXI.Container();
        const gameContainer = new PIXI.Container();

        /* ENUMS */
        const colors = {
            DISGUST: "#fffd7e", //yellow
            HAPPY: "#c7ffef", //cyan
            ANGRY: "#a9ff7e", // green
            SAD: "#ff7e7e",  //red
            WHITE: "#ffffff",
            BLACK: "#000000",
            GRAY: "#d7d7d7"
        }
        const screens = {
            START: "start",
            GAME: "game",
            END: "end"
        }
        /* ARRAY Colors*/
        const arr_colors = [colors.DISGUST, colors.HAPPY, colors.ANGRY, colors.SAD]
        /* SCREEN CHANGING*/
        /* var currentScreen = screens.START;
        function goToStart(){
            startContainer.visible = true;
            gameContainer.visible = false;
        }

        function goToGame(){
            startContainer.visible = false;
            gameContainer.visible = true;
        }

        switch(currentScreen){
            case screens.START: 
                goToStart();
                break;
            case screens.GAME: 
                goToGame();
                break;
        } */

        // TEXT STYLES
        const titleStyle = new PIXI.TextStyle({
            fontFamily: 'Courier New',
            fontSize: 48,
            fontStyle: 'italic',
            fontWeight: 'bold',
            fill: [colors.WHITE, colors.BLACK], // gradient
            stroke: colors.WHITE,
            strokeThickness: 5,
            dropShadow: true,
            dropShadowColor: colors.HAPPY,
            dropShadowBlur: 4,
            dropShadowAngle: Math.PI / 6,
            dropShadowDistance: 6,
        });
        const subtitleStyle = new PIXI.TextStyle({
            fontFamily: 'Courier New',
            fontSize: 36,
            fontStyle: 'italic',
            fontWeight: 'bold',
            fill: [colors.WHITE, colors.GRAY], // gradient
            stroke: colors.BLACK,
            strokeThickness: 5,
            dropShadow: true,
            dropShadowColor: colors.ANGRY,
            dropShadowBlur: 4,
            dropShadowAngle: Math.PI / 6,
            dropShadowDistance: 6,
        });
        const keysStyle = new PIXI.TextStyle({
            fontFamily: 'Courier New',
            fontSize: 20,
            fontStyle: 'italic',
            fontWeight: 'bold',
            fill: [colors.BLACK], // gradient
            stroke: colors.SAD,
            strokeThickness: 5,
        });

        const arrowStyle = new PIXI.TextStyle({
            fontFamily: 'Courier New',
            fontSize: 20,
            fontStyle: 'italic',
            fontWeight: 'bold',
            fill: [colors.BLACK], // gradient
            stroke: colors.DISGUST,
            strokeThickness: 5,
        });

        /* START ELEMENTS */
        // game name
        const title = new PIXI.Text('MY PATH', titleStyle);
        title.x = app.screen.width / 2.5;
        title.y = 30;
        // character
        const ghost = PIXI.Sprite.from('bunny.png');
        ghost.x = app.screen.width / 2.1;
        ghost.y = 160;
        // instructions title
        const instruction = new PIXI.Text("Instrucciones", titleStyle);
        instruction.x = app.screen.width / 3;
        instruction.y = 265;
        // keys to move
        const inst1 = new PIXI.Text("A, W, S, D", keysStyle);
        inst1.x = app.screen.width / 12;
        inst1.y = 350;
        // arrow1
        const arrow1 = new PIXI.Text("->", arrowStyle);
        arrow1.x = app.screen.width / 5;
        arrow1.y = 350;
        // text1
        const text1 = new PIXI.Text("Mover al fantasmita perdido", arrowStyle);
        text1.x = app.screen.width / 4;
        text1.y = 350;
        // game objective
        const inst2 = new PIXI.Text("Objetivo", keysStyle);
        inst2.x = app.screen.width / 12;
        inst2.y = 400;
        // arrow2
        const arrow2 = new PIXI.Text("->", arrowStyle);
        arrow2.x = app.screen.width / 5;
        arrow2.y = 400;
        // text2
        const text2 = new PIXI.Text("Elige los cristales emocionales que quieras para averiguar tu identidad", arrowStyle);
        text2.x = app.screen.width / 4;
        text2.y = 400;
        // key to exit
        const inst3 = new PIXI.Text("Esc", keysStyle);
        inst3.x = app.screen.width / 12;
        inst3.y = 450;
        // arrow3
        const arrow3 = new PIXI.Text("->", arrowStyle);
        arrow3.x = app.screen.width / 5;
        arrow3.y = 450;
        // text3
        const text3 = new PIXI.Text("Ir a inicio", arrowStyle);
        text3.x = app.screen.width / 4;
        text3.y = 450;
        // start game
        const subTitle = new PIXI.Text('Pulsar X para iniciar tu camino.', subtitleStyle);
        subTitle.x = app.screen.width / 3.5;
        subTitle.y = 550;

        /* ADD ELEMENTS TO CONTAINERS */
        startContainer.addChild(title);
        startContainer.addChild(ghost);
        startContainer.addChild(instruction);
        startContainer.addChild(inst1);
        startContainer.addChild(arrow1);
        startContainer.addChild(text1);
        startContainer.addChild(inst2);
        startContainer.addChild(arrow2);
        startContainer.addChild(text2);
        startContainer.addChild(inst3);
        startContainer.addChild(arrow3);
        startContainer.addChild(text3);
        startContainer.addChild(subTitle);
        startContainer.visible = false;
        app.stage.addChild(startContainer);

        /* GAME ELEMENTS */
        let player = PIXI.Sprite.from('Personaje_jugable_1.png');
        let enemy = PIXI.Sprite.from('bunny.png');
        let cristal1 = PIXI.Sprite.from('Cristal_diamante.png');
        let cristal2 = PIXI.Sprite.from('Cristal_pentagono.png');
        let cristal3 = PIXI.Sprite.from('Cristal_Redondo.png');
        let cristal4 = PIXI.Sprite.from('Cristal_Doble.png');
        let cristal5 = PIXI.Sprite.from('Cristal_diamante.png');
        let cristal6 = PIXI.Sprite.from('Cristal_pentagono.png');
        let cristal7 = PIXI.Sprite.from('Cristal_Redondo.png');
        let cristal8 = PIXI.Sprite.from('Cristal_Doble.png');
        let suelo = PIXI.Sprite.from('Base_dunasfondo.png');
        let suelo2 = PIXI.Sprite.from('Base_dunasfrontal.png');
        let dsert1 = PIXI.Sprite.from('Duna_01.png');
        let dsert2 = PIXI.Sprite.from('Duna_02.png');
        let dsert3 = PIXI.Sprite.from('Duna_03.png');
        let dsert4 = PIXI.Sprite.from('Duna_fondo_01.png');
        let dsert5 = PIXI.Sprite.from('Duna_fondo_02.png');
        let dsert6 = PIXI.Sprite.from('Duna_fondo_03.png');
        let obelisc = PIXI.Sprite.from('Orbe.png');
        let obelisc2 = PIXI.Sprite.from('Fondo_animado_Orbe.png');
        let background = PIXI.Sprite.from('BGOP2.png');

        // let obeliscAnimation = PIXI.Sprite.from('Fondo_animado_Orbe.png');
        enemy.y = 100
        
        cristal1.x = 1300
        cristal2.x = 1500
        cristal3.x = 1700
        cristal4.x = 1900
        cristal5.x = 2100
        cristal6.x = 2300
        cristal7.x = 2600
        cristal8.x = 2800

           // Y -> Min: 600

        cristal1.y = 500
        cristal2.y = 350
        cristal3.y = 200
        cristal4.y = 50
        cristal5.y = 500
        cristal6.y = 350
        cristal7.y = 200
        cristal8.y = 50

        cristal1.tint = arr_colors[Math.round(Math.random() * 3)]
        cristal2.tint = arr_colors[Math.round(Math.random() * 3)]
        cristal3.tint = arr_colors[Math.round(Math.random() * 3)]
        cristal4.tint = arr_colors[Math.round(Math.random() * 3)]
        cristal5.tint = arr_colors[Math.round(Math.random() * 3)]
        cristal6.tint = arr_colors[Math.round(Math.random() * 3)]
        cristal7.tint = arr_colors[Math.round(Math.random() * 3)]
        cristal8.tint = arr_colors[Math.round(Math.random() * 3)]

        

        // player.tint = 0x252525
       // obelisc.scale.set(0.7,0.7);
        obelisc.x = 900
        obelisc2.x = 900
       // obelisc.y = 0
        //obeliscAnimation.x = 750


        //START POSITIONS
        const altura = 622
        const altura2 = 560

        suelo.y =  659
        suelo2.y = 687
        dsert1.y = altura
        dsert2.y = altura
        dsert3.y = altura
        dsert4.y = altura2
        dsert5.y = altura2
        dsert6.y = altura2

        dsert1.x = 1000
        dsert2.x = 2000
        dsert3.x = 3000
        dsert4.x = 1000
        dsert5.x = 2500
        dsert6.x = 4000

     

        // ADD ELEMENTS TO GAME CONTAINER
        gameContainer.addChild(background);
    
        gameContainer.addChild(dsert4);
        gameContainer.addChild(dsert5);
        gameContainer.addChild(dsert6);
        gameContainer.addChild(suelo);
        gameContainer.addChild(obelisc2);
        gameContainer.addChild(obelisc);
        gameContainer.addChild(dsert1);
        gameContainer.addChild(dsert2);
        gameContainer.addChild(dsert3);
        gameContainer.addChild(suelo2);
       
        //gameContainer.addChild(obeliscAnimation);
        gameContainer.addChild(player);
        gameContainer.addChild(cristal1);
        gameContainer.addChild(cristal2);
        gameContainer.addChild(cristal3);
        gameContainer.addChild(cristal4);
        gameContainer.addChild(cristal5);
        gameContainer.addChild(cristal6);
        gameContainer.addChild(cristal7);
        gameContainer.addChild(cristal8);
        gameContainer.addChild(enemy);
        gameContainer.visible = true;
        app.stage.addChild(gameContainer);

        /* GAME EXECUTING */
        
        var disgust = 0
        var happy = 0
        var angry = 0
        var sad = 0
        var pSpeed = 4.5
        var moveY = 0;
        var moveX = 0;
        var wSpeed1 = 2
        var wSpeed2 = 1

        var moveY = 0;
        var moveX = 0;

        let elapsed = 0.0;
        app.ticker.add((delta) => {
            update(delta);
        });


        
        function update(delta) {
            elapsed += delta;
            player.y += moveY
            player.x += moveX
            dsert1.x -= wSpeed1
            dsert2.x -= wSpeed1
            dsert3.x -= wSpeed1
            dsert4.x -= wSpeed2
            dsert5.x -= wSpeed2
            dsert6.x -= wSpeed2
            obelisc2.y -= 10

            //Cristales Respaw
            cristal1.x -= 5
            cristalReSpawn(cristal1)
            cristalCollision(player,cristal1)
              cristal2.x -= 5
            cristalReSpawn(cristal2)
              cristalCollision(player, cristal2)
              cristal3.x -= 5
            cristalReSpawn(cristal3)
              cristalCollision(player, cristal3)
              cristal4.x -= 5
            cristalReSpawn(cristal4)
              cristalCollision(player, cristal4)
             cristal5.x -= 5
            cristalReSpawn(cristal5)
             cristalCollision(player, cristal5)
             cristal6.x -= 5
            cristalReSpawn(cristal6)
            cristalCollision(player, cristal6)
             cristal7.x -= 5
            cristalReSpawn(cristal7)
            cristalCollision(player, cristal7)
             cristal8.x -= 5
            cristalReSpawn(cristal8)
            cristalCollision(player, cristal8)

            orbAnimation(obelisc2)
            outMap(dsert1)
            outMap(dsert2)
            outMap(dsert3)
            outMapWall(dsert4)
            outMapWall(dsert5)
            outMapWall(dsert6)

            moveX *= 0.99
            moveY *= 0.99
            //console.log(moveX)

            if (hitTestRectangle(player, enemy)) {
               // console.log("Collision")
                moveY = 0
                moveX = 0
            } else {
                //console.log("Not Collision")
            }
        }

        // Movement
        function onKeyDown(key) {
            switch (key.keyCode) {
                case 87:    // W key
                case 38:    // Up arrow key 
                    moveY = -pSpeed;
                    break;
                case 83:    // S key
                case 40:    // Down arrow key
                    moveY = pSpeed;
                    break;
                case 65:    // A key
                case 37:    // Left arrow key
                    moveX = -pSpeed;
                    break;
                case 68:    // D key
                case 39:    // Right arrow key
                    moveX = pSpeed;
                    break;
                case 88:    // X key   
                    //if(currentScreen == screens.START) currentScreen = screens.GAME;
                    gameContainer.visible = true;
                    startContainer.visible = false;
                    break;
                case 27:    // Esc key
                    //if(currentScreen == screens.GAME) currentScreen = screens.START;
                    gameContainer.visible = false;
                    startContainer.visible = true;
            }

        }

        // Collisions
        function hitTestRectangle(r1, r2) {
            //Define the variables we'll need to calculate
            let hit, combinedHalfWidths, combinedHalfHeights, vx, vy;
            //hit will determine whether there's a collision
            hit = false;
            //Find the center points of each sprite
            r1.centerX = r1.x + r1.width / 2;
            r1.centerY = r1.y + r1.height / 2;
            r2.centerX = r2.x + r2.width / 2;
            r2.centerY = r2.y + r2.height / 2;
            //Find the half-widths and half-heights of each sprite
            r1.halfWidth = r1.width / 2;
            r1.halfHeight = r1.height / 2;
            r2.halfWidth = r2.width / 2;
            r2.halfHeight = r2.height / 2;
            //Calculate the distance vector between the sprites
            vx = r1.centerX - r2.centerX;
            vy = r1.centerY - r2.centerY;
            //Figure out the combined half-widths and half-heights
            combinedHalfWidths = r1.halfWidth + r2.halfWidth;
            combinedHalfHeights = r1.halfHeight + r2.halfHeight;
            //Check for a collision on the x axis
            if (Math.abs(vx) < combinedHalfWidths) {
                //A collision might be occurring. Check for a collision on the y axis
                if (Math.abs(vy) < combinedHalfHeights) {
                    //There's definitely a collision happening
                    hit = true;
                } else {
                    //There's no collision on the y axis
                    hit = false;
                }
            } else {
                //There's no collision on the x axis
                hit = false;
            }
            //`hit` will be either `true` or `false`
            return hit;
        };

        function outMap(spr) {
            if (spr.x <= -1420) {
                spr.x = 1420
               // return console.log(spr.x)
            }
        }
        function outMapWall(spr) {
            if (spr.x <= -1420) {
                spr.x = 1420
                //return spr.x
            }
        }

          function orbAnimation(spr) {
                if (spr.y <= -3200) {
                    spr.y = 0
                    //return spr.x
                }
            }

              function getRandomArbitrary(min, max) {
                    return Math.random() * (max - min) + min;
                }


            function cristalReSpawn(spr){
                let arrRandomX = [1300,1400,1500,1600,1800,2000,2200,2400]
                if (spr.x <= -1320) {
                    
                    spr.tint = arr_colors[Math.round(Math.random() * 3)]
                    spr.x = arrRandomX[Math.round(Math.random()*7)]
                    
                    if(!spr.visible){
                        spr.visible = true
                    }
                    //console.log(`New X of ${spr} = ${spr.x}`)
                   // return console.log(spr.x)
                }
            }
/*
             const colors = {
                    DISGUST: "#fffd7e", //yellow
                    HAPPY: "#c7ffef", //cyan
                    ANGRY: "#a9ff7e", // green
                    SAD: "#ff7e7e",  //red
                    WHITE: "#ffffff",
                    BLACK: "#000000",
                    GRAY: "#d7d7d7"
                }
                */
            function cristalCollision(player, cristal){
                if (hitTestRectangle(player, cristal)){
                    console.log(`player a chocado con ${happy}`)
                    if(cristal.visible){
                        switch(cristal.tint){
                            case "#fffd7e":    // Up arrow key 
                            disgust += 1
                            console.log(disgust)
                            break;
                            case "#c7ffef":    // Up arrow key 
                            happy += 1
                             console.log(happy)
                            break;
                            case "#a9ff7e":    // Up arrow key 
                            angry += 1
                             console.log(angry)
                            break;
                            case "#ff7e7e":    // Up arrow key 
                            sad += 1
                             console.log(sad)
                            break;
                        }
                       // var col = cristal.tint
                        //console.log(col)
                        cristal.visible = false
                    }
                   
                }
            }







          



    </script>
</body>

</html>